# 모델링: 클래스 설계의 토대
---------------------------
## 요약 
> 시스템은 특정 목표/목적을 위한 수단이며, 모델은 특정 목적 달성을 위해 최소한으로 요소를 갖춘 것이다. 우리가 자주 실수하는 것은 모델의 목적을 모호하게 만들기 때문이다. 

 ```
  data class User(
    val userId: Long, // 사용자 id 
    val companyId: Long, // 회사 계정 id
    val name: Long, // 사용자 이름 
    val account: Long, // 회사 결제 정보 
  )
```
위와 같이, `User`의 개인 사용자 정보와 회사 계정 정보가 혼합 되어 있기 쉽다. 이렇게 혼합되어 있다보면, 추후 개인 사용자 혹은 회사 사용자만 계산해야 하는 로직에서 오류가 발생할 수 있다. 이를 해결 하기 위해서는

### 1. 네이밍의 목적을 표현하기 
```
  data class PersonalUser()
  data class CompanyUser()
 ```
각 목적에 맞는 클래스를 분리하고, 이름을 구체적으로 지어보자. 이렇게 되면, 클래스가 단일 책임, 단일 목적을 가지게 되어 객체지향 프로그래밍에서 지향하는 방식으로 설계를 할 수 있다. 
<br/>
<br/>
<br/>


### 2. 클래스를 세분화할 때, 목적으로 분류해보기
모델 간의 구조를 만들 때, 목적으로 분류해서 만들어보기

##### 기존 
```
class Payment()
class Card() : Payment()
class Cash() : Payment()
```
결제 수단이라는 틀 안에서 본다면, 카드, 현금 등 결제할 수 있는 수단들만 보여진 모델 구조를 가질 수 밖에 없습니다. 만약에 사용자의 주문 방식을 카운팅해야 한다면 어땧게 바꾸는 것이 좋을까요.. 

##### 개선 후 
```
class Order() // 주문 방식 
class Card() : Order() // 카드 
class Cash() : Order() // 현금
class Kiosk() : Order() // 키오스크
class Person() : Order() // 직접 결제
class Application() : Order() // 앱결제 
```
최근에는 결제수단이 다양하게 들어났습니다. 특정 앱으로 미리 주문해놓ㅇ르 수 있고, 카드, 키오스크 등 주문 방식을 목적으로 재설개하볼 수 있습니다. 
<br/>
<br/>
<br/>



> 설계는 한 번만 해보았다고 끝나는 것이 아니라 매일매일 반복해서 개선하는 것이다. 




