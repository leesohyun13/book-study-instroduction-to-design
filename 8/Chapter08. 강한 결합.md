# 08장 강한 결합: 복잡하게 얽혀서 풀 수 없는 구조 

## 결합도와 책무
**결합도**   
> 모듈 사이 혹은 클래스 사이의 의존도를 나타내는 지표. 의존도가 높은 경우, A와 B 클래스 사이의 결합도가 높다고 표현한다. 

**책무**   
> 책임과 의무로, 객체가 자신이 맡은 책임과 의무를 다해야 한다.    


객체지향 프로그래밍에서 객체는 `단일 책임 원칙`기반으로 설계해야 합니다. 각 객체는 자신이 의무적으로 맡아야 하는 하나의 책임을 가져야 합니다. 
만약에 한 객체가 두 가지 이상의 책임을 지고 있는 경우, 다른 객채의 책임을 지고 있기에 결합도가 높은 상황일 수 있습니다. 혹은 코드가 중복되는 일이 발생하게 됩니다. 

```
// 상품 가격 
class Price {
  // SummerDiscountedPrice, RegularDiscountedPrice
}
// 할인 가격 
class RegularDiscountedPrice {
  
}
// 여름 할인 가격
class SummerDiscountedPrice {
  
}
```
상품 가격 관련된 개념을 각각 class로 쪼개여 `느슨한 결합`을 만들 수 있습니다. 

> 책무를 생각하지 않고, 로직의 중복을 제거하면 안됩니다.
DRY원칙을 생각하고 중복코드를 무조건 최소화 하는 것이 좋다고 생각한 적이 있다. 각 객체마다 로직은 중복되었지만, 개념은 다르기 때문에 중복된 코드가 아닐 수 있다.
하지만 현업에서 다른 개념이지만 중복된 로직이고, 해당 로직을 항상 동일하게 관리해야 할 때는 어떻게 하면 좋을까...?
<br>

## 다양한 강한 결합 사례와 대처 방법 
### 1) 상속과 관련된 강한 결합
상속은 `super()` 로직으로 인해 강한 결합과 중복 로직이 발생할 수 있다. 상속을 여러번 하는 경우, 서브 클래스와 슈퍼 클래스의 구조를 하나하나 신경 써야 한다. 그래서 상속보다는 컴포지션 구조가 덜 위험하다. 
공통 로직을 위해 상속을 사용하는 경우 슈퍼 클래스의 공통 로직을 두는 장소가 된다. 상속으로 무리한 일반화하려고 하면 강한 결합이 발생하기 쉽다. 
상속은 다른 동적을 구현하기 위해 사용하는 것이다. + 전략패턴으로 조건 분기를 줄일 때, 활용하면 좋다. 


### 3) pulicb function
특별한 이유없이 `public`을 붙이면 강한 결합 구조가 된다.    

### 4) private 메서드가 너무 많다는 것은 책임이 많다는 것 
`private`인 메서드가 너무 많다는 것은 너무 많은 책임을 가지고 있는 가능성이 높다.    

### 5) 높은 응집도로 오해해서 생기는 강한 결합   
응집도가 높아야 하지만, 반면에 로직으로 한곳에 모으려고 하는 것은 강한 결합 구조를 만들 수 있다. 4번과 비슷하게, 한 곳에 너무 많은 책임이 생기게 되면, 해당 객체를 더 쪼갤 수 있다는 것을 의미하기도 한다. 

### 7) 거대 클래스 
클래서그 너무 커지면 거대 클래스가 되기 때문의 주의해야 한다. 

### 8) 트랜쟉션 스크립트 패턴
'데이터를 보유하고 있는 클래스'와 '데이터를 처리하는 클래스'를 나누어 구현할 떄 많이 발생한다. 이렇게 되면 하나의 책임을 분리하여 구현하고 있는 것이다. 

### 9) 갓클래스
하나의 클래스 내부에서 수천 줄 이상의 로직을 담고 있다는 것. 프론트의 경우 `viewModel`에서 이와 같은 로직을 많이 갖게 된다.    
<br>

## 결론
객체 지향 설계와 단일 책임 원칙에 따라 설계해야 한다. 조기 리턴, 전략 패턴, 일급 컬렉션 등 활용해보면 좋다고 한다.    

